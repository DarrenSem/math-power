<!DOCTYPE html><html><head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Math Power!</title>

<style type="text/css">

#container-calculate {
  padding-top: 1rem;
}

</style>

</head><body>

<h1>Math Power!</h1>

<label>
  number 1 👉🏽
  <input id="num1"
    autofocus
    maxlength="30"
    size="5"
    tXYZype="number(disabled because this means it ignores maxlength and visible size)"
    step="0.01"
  >
</label>

<label>
  <select id="operator">
    <option value="">-- Choose Operator --</option>
    <option value="to the power of">to the power of</option>
    <option value="plus">plus</option>
    <option value="minus">minus</option>
    <option value="times">times</option>
    <option value="divided by">divided by</option>
  </select>
</label>

<label>
  <input id="num2"
    maxlength="30"
    size="5"
    tXYZype="number(disabled because this means it ignores maxlength and visible size)"
    step="0.01"
  >
  👈🏽 number 2
</label>

<div id="container-calculate">
  <button onClick="calculate()">Equals:</button>
  <input type="text" id="result" readonly>
</div>

<script>

// {  // putting all code inside block = non-polluting like an IIFE (likely never will need this tho)

  const getLocation = () => {
    // TODO: future might mock during testing?
    const loc = new URL("" || location); 
    return loc;
  };

  const LOC = getLocation();

  const qi = id => document.getElementById(id);

  const num1El = qi("num1");
  const operatorEl = qi("operator");
  const num2El = qi("num2");
  const resultEl = qi("result");

  const setFieldsData = (num1, operator, num2) => {
    num1El.value = num1;
    operatorEl.value = operator;
    num2El.value = num2;
  };

  const getArgsData = href => {

    if(!/\?/.test(href))return null;

    // new URL(href), because new URLSearchParams(href) seems to skip the 1st param immediately after "?"
    const p = new URL(href).searchParams;

    setFieldsData(
      p.get("num1") ?? "",  // briefer than p.has("num1") ? p.get("num1") : ""
      p.get("operator") ?? "",
      p.get("num2") ?? ""
    );

    // return undefined, to ensure getFieldsData parses the values we just moved into the fields
    return;
  };

  const getFieldsData = () => {
    const num1 = num1El.value;
    const operator = operatorEl.value;
    const num2 = num2El.value;
    return { num1, operator,num2 };
  };

  const calculate = data => {

    if(data === null) {
      data = getArgsData(LOC.href);

      if(data === null) {
        return;
      };
    };

    if(data == null) {
      // default logic if undefined (getArgsData had args to parse, or button was clicked)
      data = getFieldsData();
    };

    let {num1, num2, operator} = data;

    setFieldsData(num1, operator, num2);  // for visual consistency if calculate({key:value})

    num1 = parseFloat(num1);
    num2 = parseFloat(num2);

    const operations = {
      "to the power of": (num1, num2) => Math.pow(num1, num2),
      "plus": (num1, num2) => num1 + num2,
      "minus": (num1, num2) => num1 - num2,
      "times": (num1, num2) => num1 * num2,
      "divided by": (num1, num2) => num1 / num2,
    };

    const fn = operations[operator];

    if(!fn) {
      operatorEl.focus();
      alert("Please select an operator");
      return;
    };

    const result = fn(num1, num2);

    resultEl.value = result;
    resultEl.focus();
    resultEl.select();

    return result;
  };

  const main = (window, setTimeout, delay) => {
    // auto-calculate based on getArgsData only (silently skipped if no args passed)
    window.onload = setTimeout( () => calculate(null), delay);
  };

  // TODO: could modify later for Node or invisible testing to work too, idk
  main(window, setTimeout, 100);

// };

</script>

</body></html>
